# STL- 常用算法

统一的容器设计使得不同类型的容器之间具有明显关系。例如，可以使用copy( )将常规数组中的值复制到vector对象中，将vector对象中的值复制到list对象中，将list对象中的值复制到set对象中。可以用= =来比较不同类型的容器，如deque和vector。之所以能够这样做，是因为容器重载的= =运算符使用迭代器来比较内容，因此如果deque对象和vector对象的内容相同，并且排列顺序也相同，则它们是相等的。   
+ 算法主要是由头文件`<algorithm> <functional> <numeric>`组成。

+ `<algorithm>`是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等

+ `<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数

+ `<functional>`定义了一些模板类,用以声明函数对象。内建仿函数

STL将算法库分成4组：
+ 非修改式序列操作；
+ 修改式序列操作；
+ 排序和相关操作；
+ 通用数字运算。

前3组在头文件algorithm（以前为algo.h）中描述。   

非修改式序列操作对区间中的每个元素进行操作。这些操作不修改容器的内容。例如，find( )和for_each( )就属于这一类。   

修改式序列操作也对区间中的每个元素进行操作。然而，顾名思义，它们可以修改容器的内容。可以修改值，也可以修改值的排列顺序。transform( )、random_shuffle( )和copy( )属于这一类。    

排序和相关操作包括多个排序函数（包括sort( )）和其他各种函数，包括集合操作。   

数字操作包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此vector是最有可能使用这些操作的容器。    

## 常见变体

有些算法有两个版本：就地版本和复制版本。STL的约定是，复制版本的名称将以_copy结尾。复制版本将接受一个额外的输出迭代器参数，该参数指定结果的放置位置。例如replace 和replace_copy   

对于复制算法，统一的约定是：返回一个迭代器，该迭代器指向复制的最后一个值后面的一个位置。   

另一个常见的变体是：有些函数有这样的版本，即根据将函数应用于容器元素得到的结果来执行操作。这些版本的名称通常以_if结尾。例如，如果将函数用于旧值时，返回的值为true，则replace_if( )将把旧值替换为新的值。 


## 常用遍历算法

+ 实现遍历容器`for_each(iterator beg, iterator end, _func);` _func 函数或者函数对象
`for_each(v.begin(), v.end(), print01);`

+ 搬运容器到另一个容器中`transform(iterator beg1, iterator end1, iterator out_beg2, _func);`
+ 第2种版本使用一个接受两个参数的函数，并将该函数用于两个区间中元素。它用另一个参数（即第3个）标识第二个区间的起始位置。   
  `transform(iterator beg1, iterator end1, iterator beg2,iterator out_beg3， _func)`   

## 常用查找算法

+ find //查找元素 ,找到就会break
+ find_if //按条件查找元素
+ adjacent_find //查找相邻重复元素,返回相邻元素的第一个位置的迭代器
+ binary_search //二分查找法，查找指定的元素，查到 返回true 否则false，**在无序序列中不可用**
+ count //统计元素个数
+ count_if //按条件统计元素个数

## 常用排序算法

+ sort //对容器内元素进行排序
+ random_shuffle //洗牌 指定范围内的元素随机调整次序
+ merge // 容器元素合并，并存储到另一容器中
+ reverse // 反转指定范围的元素

`sort(iterator beg, iterator end, _Pred);`按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

